1ï¸âƒ£Fetch API 
    ðŸŽ¯ INTERVIEW GOLD ANSWER (FINAL)
        Fetch API is a browser Web API that allows JavaScript to make HTTP requests. It returns a Promise that resolves to a Response object, not the actual data. The browser handles the network request, and the response is processed asynchronously using Promises or async/await. Fetch does not reject on HTTP errors like 404, so developers must manually handle errors using response.ok.

    ðŸ“Œ Key point (VERY IMPORTANT):
        Fetch is NOT part of JavaScript language
        Fetch is part of the Browser (Web APIs)

2ï¸âƒ£ What does fetch() return? (CORE CONCEPT)
    const response = fetch(url); -> return -> Promise { <pending> }
    âš ï¸ It does NOT return data
    âš ï¸ It does NOT wait for the network

3ï¸âƒ£ What happens internally when you call fetch()?
    CODE:-
        fetch("https://dummyjson.com/products");

    JS Code
        â†“
    fetch() called
        â†“
    Browser starts network request
        â†“
    fetch() returns Promise (pending)
        â†“
    JS continues execution

4ï¸âƒ£ FULL INTERNAL ARCHITECTURE (TEXT DIAGRAM)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              JS ENGINE                   â”‚
    â”‚                                          â”‚
    â”‚  Call Stack                              â”‚
    â”‚   â””â”€ fetch(url)                          â”‚
    â”‚                                          â”‚
    â”‚  Memory Heap                             â”‚
    â”‚   â””â”€ response = Promise(pending)         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ async work
                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              WEB APIs (Browser)          â”‚
    â”‚                                          â”‚
    â”‚   fetch()                                â”‚
    â”‚    â””â”€ DNS lookup                         â”‚
    â”‚    â””â”€ TCP connection                     â”‚
    â”‚    â””â”€ HTTPS handshake                    â”‚
    â”‚    â””â”€ Send HTTP request                  â”‚
    â”‚    â””â”€ Wait for response                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ response arrives
                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚          PROMISE SETTLED                 â”‚
    â”‚   âœ” fulfilled  OR  âŒ rejected          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         MICROTASK QUEUE                  â”‚
    â”‚   (.then / .catch callbacks)             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             CALL STACK                   â”‚
    â”‚     callbacks executed                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    

5ï¸âƒ£ What does fetch resolve with?
    âœ… A Response object
        fetch(url)
        .then(res => {
            console.log(res);
        });
    res:-
        Response {
            status: 200,
            ok: true,
            headers: {...},
            body: ReadableStream
        }
        â”‚ 
        â””â”€â”€â”€>   âš ï¸ body â‰  data
                âš ï¸ body = ReadableStream
        

6ï¸âƒ£ Why do we need res.json()?
    ->Because response body is a stream, not actual data.
    ->res.json() 
        ðŸ‘‰ Reads the stream
        ðŸ‘‰ Converts JSON â†’ JS object
        ðŸ‘‰ Returns another Promise
        ->Promise { <pending> }

    ->fetch()        â”‚ Promise
    ->res.json()     â”‚ Promise

    ðŸ§  What is a stream? (Simple meaning)
        Data comes piece by piece
        Not all at once
        Browser reads it gradually

    ðŸ§  Why browser uses stream?
        Response can be very large (MBs / GBs)
        Browser cannot load everything into memory at once
        Streaming saves memory & improves performance
    
    â—Important thing many people miss
        res.json() does TWO jobs:
            1. Reads the stream completely
            2. Converts JSON â†’ JS object
        And it returns a Promise.
    
    ðŸ” INTERNAL FLOW (TEXT DIAGRAM)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     fetch(url)             â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      Response object       â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      body = ReadableStream â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      res.json()            â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      read stream fully     â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      parse JSON            â”‚ 
    â”‚          â†“                 â”‚ 
    â”‚      JS object             â”‚ 
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7ï¸âƒ£ Why fetch DOES NOT fail on 404? (VERY IMPORTANT)
    HTTP Error (404, 500) â‰  Network Error
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Situation    â”‚  fetch behavior      â”‚ 
    â”‚ ------------ â”‚  ------------------  â”‚ 
    â”‚  No internet â”‚  âŒ Promise rejected â”‚ 
    â”‚  DNS failure â”‚  âŒ Promise rejected â”‚ 
    â”‚  404 / 500   â”‚  âœ… Promise resolved â”‚ 
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
    ðŸ“Œ Because server responded successfully
    (HTTP error is still a valid HTTP response)

    âŒ BAD CODE (Common mistake)
        fetch(url)
          .then(res => res.json()) // âŒ unsafe

        If 404:
            Response body may be empty
            JSON parsing fails
            You get Unexpected end of JSON input
    
    âœ… CORRECT PATTERN (MANDATORY)
        fetch(url)
        .then(res => {
            if (!res.ok) {
            throw new Error(`HTTP error ${res.status}`);
            }
            return res.json();
        })
        .then(data => console.log(data))
        .catch(err => console.error(err.message));
    
    ðŸ§  ONE-LINE MEMORY (STREAM)
        Fetch response body is a stream, so we must read it using res.json(), which itself is asynchronous. 

8ï¸âƒ£ Promise + Event Loop connection (DEEP)
    Fetch callbacks go where?
    ðŸ‘‰ Microtask Queue
        Promise.then()
        Promise.catch()

    ðŸ”¥Priority order:
        Call Stack
            â†“
        Microtask Queue (fetch, promise)
            â†“
        Callback Queue (setTimeout)

    ðŸ‘‹Thatâ€™s why:
        setTimeout(() => console.log("timeout"), 0);
        fetch(url).then(() => console.log("fetch"));
        â”‚ 
        â””â”€â”€â”€>   fetch
                timeout

9ï¸âƒ£ Fetch + async/await (What REALLY happens)
    Most people think ðŸ‘‡
        await blocks JavaScript âŒ
    That is 100% wrong.

    ðŸ§  Truth about await
        await pauses ONLY the async function, not the whole JS engine
    
    ðŸ“Œ Example code
        async function getData() {
            console.log("A");
            const res = await fetch(url);
            console.log("B");
            const data = await res.json();
            console.log("C");
        }

        console.log("Start");
        getData();
        console.log("End");
            â”‚ 
            â””â”€â”€â”€>   Start
                    A
                    End
                    B
                    C

    ðŸ” async/await INTERNAL DIAGRAM
        async function
            â†“
        await Promise
            â†“
        pause function
            â†“
        Promise resolved
            â†“
        microtask queue
            â†“
        resume function

    ðŸ§  ONE-LINE MEMORY (ASYNC/AWAIT)
        await pauses the async function, returns control to JavaScript, and resumes execution via the microtask queue when the Promise settles. 



ðŸ”Ÿ POST request (Internal view)
    fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(data)
    });
    â”‚ 
    â””â”€â”€â”€>   JS â†’ Web API
            â†’ HTTP request with body
            â†’ server processes
            â†’ response
            â†’ Promise resolved
